import { __toESM, require_react } from "./react-BaqBjuxQ.js";
import { require_jsx_runtime } from "./jsx-runtime-DSm6idpZ.js";
import { useEventCallback } from "./NavbarContext-CeuWOIda.js";

//#region node_modules/@restart/ui/node_modules/@restart/hooks/esm/useForceUpdate.js
var import_react = /* @__PURE__ */ __toESM(require_react());
/**
* Returns a function that triggers a component update. the hook equivalent to
* `this.forceUpdate()` in a class component. In most cases using a state value directly
* is preferable but may be required in some advanced usages of refs for interop or
* when direct DOM manipulation is required.
*
* ```ts
* const forceUpdate = useForceUpdate();
*
* const updateOnClick = useCallback(() => {
*  forceUpdate()
* }, [forceUpdate])
*
* return <button type="button" onClick={updateOnClick}>Hi there</button>
* ```
*/
function useForceUpdate() {
	const [, dispatch] = (0, import_react.useReducer)((revision) => revision + 1, 0);
	return dispatch;
}

//#endregion
//#region node_modules/@restart/ui/node_modules/@restart/hooks/esm/useEventListener.js
/**
* Attaches an event handler outside directly to specified DOM element
* bypassing the react synthetic event system.
*
* @param element The target to listen for events on
* @param event The DOM event name
* @param handler An event handler
* @param capture Whether or not to listen during the capture event phase
*/
function useEventListener(eventTarget, event, listener, capture = false) {
	const handler = useEventCallback(listener);
	(0, import_react.useEffect)(() => {
		const target = typeof eventTarget === "function" ? eventTarget() : eventTarget;
		target.addEventListener(event, handler, capture);
		return () => target.removeEventListener(event, handler, capture);
	}, [eventTarget]);
}

//#endregion
//#region node_modules/@restart/ui/node_modules/@restart/hooks/esm/useCallbackRef.js
/**
* A convenience hook around `useState` designed to be paired with
* the component [callback ref](https://reactjs.org/docs/refs-and-the-dom.html#callback-refs) api.
* Callback refs are useful over `useRef()` when you need to respond to the ref being set
* instead of lazily accessing it in an effect.
*
* ```ts
* const [element, attachRef] = useCallbackRef<HTMLDivElement>()
*
* useEffect(() => {
*   if (!element) return
*
*   const calendar = new FullCalendar.Calendar(element)
*
*   return () => {
*     calendar.destroy()
*   }
* }, [element])
*
* return <div ref={attachRef} />
* ```
*
* @category refs
*/
function useCallbackRef() {
	return (0, import_react.useState)(null);
}

//#endregion
//#region node_modules/@restart/ui/esm/NavContext.js
var NavContext = /* @__PURE__ */ import_react.createContext(null);
NavContext.displayName = "NavContext";
var NavContext_default = NavContext;

//#endregion
//#region node_modules/@restart/ui/esm/Button.js
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime());
var _excluded$1 = ["as", "disabled"];
function _objectWithoutPropertiesLoose$1(r, e) {
	if (null == r) return {};
	var t = {};
	for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
		if (e.indexOf(n) >= 0) continue;
		t[n] = r[n];
	}
	return t;
}
function isTrivialHref$1(href) {
	return !href || href.trim() === "#";
}
function useButtonProps({ tagName, disabled, href, target, rel, role, onClick, tabIndex = 0, type }) {
	if (!tagName) if (href != null || target != null || rel != null) tagName = "a";
	else tagName = "button";
	const meta = { tagName };
	if (tagName === "button") return [{
		type: type || "button",
		disabled
	}, meta];
	const handleClick = (event) => {
		if (disabled || tagName === "a" && isTrivialHref$1(href)) event.preventDefault();
		if (disabled) {
			event.stopPropagation();
			return;
		}
		onClick?.(event);
	};
	const handleKeyDown = (event) => {
		if (event.key === " ") {
			event.preventDefault();
			handleClick(event);
		}
	};
	if (tagName === "a") {
		href || (href = "#");
		if (disabled) href = void 0;
	}
	return [{
		role: role != null ? role : "button",
		disabled: void 0,
		tabIndex: disabled ? void 0 : tabIndex,
		href,
		target: tagName === "a" ? target : void 0,
		"aria-disabled": !disabled ? void 0 : disabled,
		rel: tagName === "a" ? rel : void 0,
		onClick: handleClick,
		onKeyDown: handleKeyDown
	}, meta];
}
var Button = /* @__PURE__ */ import_react.forwardRef((_ref, ref) => {
	let { as: asProp, disabled } = _ref, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$1);
	const [buttonProps, { tagName: Component }] = useButtonProps(Object.assign({
		tagName: asProp,
		disabled
	}, props));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, Object.assign({}, props, buttonProps, { ref }));
});
Button.displayName = "Button";
var Button_default = Button;

//#endregion
//#region node_modules/@restart/ui/esm/Anchor.js
var _excluded = ["onKeyDown"];
function _objectWithoutPropertiesLoose(r, e) {
	if (null == r) return {};
	var t = {};
	for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
		if (e.indexOf(n) >= 0) continue;
		t[n] = r[n];
	}
	return t;
}
function isTrivialHref(href) {
	return !href || href.trim() === "#";
}
/**
* An generic `<a>` component that covers a few A11y cases, ensuring that
* cases where the `href` is missing or trivial like "#" are treated like buttons.
*/
var Anchor = /* @__PURE__ */ import_react.forwardRef((_ref, ref) => {
	let { onKeyDown } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded);
	const [buttonProps] = useButtonProps(Object.assign({ tagName: "a" }, props));
	const handleKeyDown = useEventCallback((e) => {
		buttonProps.onKeyDown(e);
		onKeyDown?.(e);
	});
	if (isTrivialHref(props.href) || props.role === "button") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", Object.assign({ ref }, props, buttonProps, { onKeyDown: handleKeyDown }));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", Object.assign({ ref }, props, { onKeyDown }));
});
Anchor.displayName = "Anchor";
var Anchor_default = Anchor;

//#endregion
export { Anchor_default, Button_default, NavContext_default, useButtonProps, useCallbackRef, useEventListener, useForceUpdate };
//# sourceMappingURL=Anchor-DX3xL-ki.js.map